<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Table (Selected Columns)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tailwind (optional modern styling) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Papa Parse for robust CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">
  <main class="max-w-6xl mx-auto p-6">
    <div class="bg-white shadow rounded-xl p-5">
      <div class="flex items-center justify-between mb-4">
        <h1 class="text-xl md:text-2xl font-bold text-blue-700">KTP Status Checklist</h1>
        <button id="reload" class="px-3 py-2 text-sm bg-blue-600 hover:bg-blue-700 text-white rounded-md">Reload</button>
      </div>
      <div id="table-container" class="overflow-x-auto text-sm">Loading...</div>
    </div>
  </main>

  <script type="module">
    // UPDATE THIS to your CSV raw URL (GitHub, etc.)
    // Example: 'https://raw.githubusercontent.com/<user>/<repo>/<branch>/452-Check%20List-KTP.csv'
    const CSV_URL = 'https://raw.githubusercontent.com/<user>/<repo>/<branch>/452-Check%20List-KTP.csv';

    // Only these columns will be shown (in this exact order)
    const TARGET_HEADERS = [
      'Status', 'NO.', 'Date', 'Group', 'Safety',
      'Prelab', 'Full Report', 'Calculation', 'Due', 'Over Due'
    ];

    // Some files may contain slight header variations (extra spaces, punctuation).
    // We'll normalize headers to find matches safely.
    const normalize = (s) =>
      String(s ?? '')
        .toLowerCase()
        .replace(/\s+/g, '')       // remove spaces
        .replace(/[._-]+/g, '')    // remove dots/underscores/hyphens
        .replace(/[:;/\\]+/g, ''); // remove other punctuations

    // Accept both 'Prelab ' (with space) and 'Prelab'
    const ACCEPTABLE_VARIANTS = {
      'Prelab': ['Prelab', 'Prelab '],
      'NO.': ['NO.', 'No.', 'NO', 'No'],
      'Over Due': ['Over Due', 'OverDue', 'Overdue', 'Over  Due']
    };

    function buildHeaderMap(csvHeaders) {
      const map = {};
      const normalizedCsv = csvHeaders.map(h => ({ raw: h, norm: normalize(h) }));

      for (const target of TARGET_HEADERS) {
        // Candidate header names (target + known variants)
        const candidates = new Set([target, ...(ACCEPTABLE_VARIANTS[target] || [])]);

        // 1) Exact raw match
        let found = csvHeaders.find(h => candidates.has(h));
        if (!found) {
          // 2) Trimmed exact match
          found = csvHeaders.find(h => candidates.has(String(h).trim()));
        }
        if (!found) {
          // 3) Normalized match
          const normTargetCandidates = [...candidates].map(normalize);
          const match = normalizedCsv.find(o => normTargetCandidates.includes(o.norm));
          if (match) found = match.raw;
        }

        // As a last resort, attempt loose normalized matching (e.g., 'OverDue' vs 'Over Due')
        if (!found) {
          const normTarget = normalize(target);
          const match = normalizedCsv.find(o => o.norm === normTarget);
          if (match) found = match.raw;
        }

        map[target] = found || null; // may be null if not found
      }
      return map;
    }

    function renderTableFromObjects(rows, headerMap) {
      const container = document.getElementById('table-container');

      if (!rows || rows.length === 0) {
        container.innerHTML = '<p class="text-gray-500">No data available.</p>';
        return;
      }

      // Build thead
      const thead = `
        <thead>
          <tr>
            ${TARGET_HEADERS.map(h => `
              <th class="px-3 py-2 bg-blue-50 text-left font-semibold border-b border-gray-200">${h}</th>
            `).join('')}
          </tr>
        </thead>
      `;

      // Build tbody with only selected columns (respecting order)
      const tbody = `
        <tbody>
          ${rows.map(row => {
            const tds = TARGET_HEADERS.map(h => {
              const key = headerMap[h];
              const val = key ? (row[key] ?? '') : '';
              return `<td class="px-3 py-2 border-b border-gray-100">${val}</td>`;
            }).join('');
            return `<tr class="odd:bg-gray-50 hover:bg-yellow-50">${tds}</tr>`;
          }).join('')}
        </tbody>
      `;

      container.innerHTML = `
        <table class="min-w-full border border-gray-200 rounded-lg overflow-hidden">
          ${thead}
          ${tbody}
        </table>
      `;
    }

    async function loadCsvObjects(url) {
      const bust = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now();
      const res = await fetch(bust, { cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to fetch CSV: ' + res.status);
      const text = await res.text();
      const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
      if (parsed.errors?.length) {
        console.warn('CSV parse warnings:', parsed.errors.slice(0, 3));
      }
      return { rows: parsed.data, headers: parsed.meta.fields || [] };
    }

    async function loadAndRender() {
      const container = document.getElementById('table-container');
      container.innerHTML = 'Loading...';
      try {
        const { rows, headers } = await loadCsvObjects(CSV_URL);
        const headerMap = buildHeaderMap(headers);
        renderTableFromObjects(rows, headerMap);
      } catch (e) {
        console.error(e);
        container.innerHTML = '<p class="text-red-600">Failed to load data.</p>';
      }
    }

    document.getElementById('reload').addEventListener('click', loadAndRender);
    loadAndRender();
  </script>
</body>
</html>